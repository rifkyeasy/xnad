
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
// biome-ignore-all lint: generated file

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  DbNull,
  JsonNull,
  AnyNull,
  NullTypes,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require('./runtime/client.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
Prisma.prismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = DbNull
Prisma.JsonNull = JsonNull
Prisma.AnyNull = AnyNull

Prisma.NullTypes = NullTypes




  const path = require('path')

/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.UserScalarFieldEnum = {
  id: 'id',
  walletAddress: 'walletAddress',
  vaultAddress: 'vaultAddress',
  xHandle: 'xHandle',
  xUserId: 'xUserId',
  xAnalysis: 'xAnalysis',
  strategyType: 'strategyType',
  confidenceThreshold: 'confidenceThreshold',
  maxTradeAmount: 'maxTradeAmount',
  autoTrade: 'autoTrade',
  autoRebalance: 'autoRebalance',
  rebalanceInterval: 'rebalanceInterval',
  stopLossPercent: 'stopLossPercent',
  takeProfitPercent: 'takeProfitPercent',
  riskProfile: 'riskProfile',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.TradeScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  tokenAddress: 'tokenAddress',
  tokenSymbol: 'tokenSymbol',
  action: 'action',
  amountIn: 'amountIn',
  amountOut: 'amountOut',
  priceAtTrade: 'priceAtTrade',
  confidence: 'confidence',
  signalSource: 'signalSource',
  reasoning: 'reasoning',
  txHash: 'txHash',
  status: 'status',
  error: 'error',
  createdAt: 'createdAt',
  executedAt: 'executedAt'
};

exports.Prisma.PositionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  tokenAddress: 'tokenAddress',
  tokenSymbol: 'tokenSymbol',
  balance: 'balance',
  costBasis: 'costBasis',
  entryPrice: 'entryPrice',
  currentPrice: 'currentPrice',
  currentValue: 'currentValue',
  unrealizedPnl: 'unrealizedPnl',
  unrealizedPnlPct: 'unrealizedPnlPct',
  targetAllocation: 'targetAllocation',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.StrategyPerformanceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  strategyType: 'strategyType',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  tradesCount: 'tradesCount',
  winCount: 'winCount',
  lossCount: 'lossCount',
  winRate: 'winRate',
  totalPnl: 'totalPnl',
  totalPnlPct: 'totalPnlPct',
  bestTrade: 'bestTrade',
  worstTrade: 'worstTrade',
  avgTradeSize: 'avgTradeSize',
  createdAt: 'createdAt'
};

exports.Prisma.TokenWhitelistScalarFieldEnum = {
  id: 'id',
  tokenAddress: 'tokenAddress',
  tokenSymbol: 'tokenSymbol',
  riskLevel: 'riskLevel',
  minMarketCap: 'minMarketCap',
  verified: 'verified',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.AgentLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  action: 'action',
  details: 'details',
  success: 'success',
  error: 'error',
  createdAt: 'createdAt'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.NullableJsonNullValueInput = {
  DbNull: Prisma.DbNull,
  JsonNull: Prisma.JsonNull
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.JsonNullValueFilter = {
  DbNull: Prisma.DbNull,
  JsonNull: Prisma.JsonNull,
  AnyNull: Prisma.AnyNull
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};
exports.StrategyType = exports.$Enums.StrategyType = {
  CONSERVATIVE: 'CONSERVATIVE',
  BALANCED: 'BALANCED',
  AGGRESSIVE: 'AGGRESSIVE'
};

exports.TradeAction = exports.$Enums.TradeAction = {
  BUY: 'BUY',
  SELL: 'SELL'
};

exports.TradeStatus = exports.$Enums.TradeStatus = {
  PENDING: 'PENDING',
  EXECUTING: 'EXECUTING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

exports.RiskLevel = exports.$Enums.RiskLevel = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

exports.Prisma.ModelName = {
  User: 'User',
  Trade: 'Trade',
  Position: 'Position',
  StrategyPerformance: 'StrategyPerformance',
  TokenWhitelist: 'TokenWhitelist',
  AgentLog: 'AgentLog'
};
/**
 * Create the Client
 */
const config = {
  "previewFeatures": [],
  "clientVersion": "7.3.0",
  "engineVersion": "9d6ad21cbbceab97458517b147a6a09ff43aa735",
  "activeProvider": "postgresql",
  "inlineSchema": "generator client {\n  provider = \"prisma-client-js\"\n  output   = \"../generated/prisma/client\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n}\n\n// User profile and settings\nmodel User {\n  id            String  @id @default(cuid())\n  walletAddress String  @unique\n  vaultAddress  String?\n\n  // X/Twitter integration\n  xHandle   String?\n  xUserId   String?\n  xAnalysis Json? // Stored analysis results\n\n  // Strategy settings\n  strategyType        StrategyType @default(BALANCED)\n  confidenceThreshold Float        @default(0.7)\n  maxTradeAmount      Float        @default(0.05)\n\n  // Automation settings\n  autoTrade         Boolean @default(false)\n  autoRebalance     Boolean @default(false)\n  rebalanceInterval Int     @default(24) // hours\n  stopLossPercent   Float?\n  takeProfitPercent Float?\n\n  // Risk profile from X analysis\n  riskProfile String?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  trades      Trade[]\n  positions   Position[]\n  performance StrategyPerformance[]\n}\n\nenum StrategyType {\n  CONSERVATIVE\n  BALANCED\n  AGGRESSIVE\n}\n\n// Individual trade records\nmodel Trade {\n  id     String @id @default(cuid())\n  userId String\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  tokenAddress String\n  tokenSymbol  String\n  action       TradeAction\n\n  // Amounts (stored as strings for precision)\n  amountIn     String\n  amountOut    String\n  priceAtTrade String\n\n  // Signal info\n  confidence   Float\n  signalSource String? // \"x_analysis\", \"rebalance\", \"stop_loss\", \"take_profit\"\n  reasoning    String?\n\n  // Transaction\n  txHash String?\n  status TradeStatus @default(PENDING)\n  error  String?\n\n  createdAt  DateTime  @default(now())\n  executedAt DateTime?\n\n  @@index([userId])\n  @@index([tokenAddress])\n  @@index([status])\n}\n\nenum TradeAction {\n  BUY\n  SELL\n}\n\nenum TradeStatus {\n  PENDING\n  EXECUTING\n  SUCCESS\n  FAILED\n  CANCELLED\n}\n\n// Current token positions\nmodel Position {\n  id     String @id @default(cuid())\n  userId String\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  tokenAddress String\n  tokenSymbol  String\n\n  // Holdings\n  balance    String // Token balance\n  costBasis  String // Total MON spent\n  entryPrice String // Average entry price\n\n  // Current values\n  currentPrice String\n  currentValue String\n\n  // P&L\n  unrealizedPnl    String\n  unrealizedPnlPct Float\n\n  // Rebalancing\n  targetAllocation Float? // Target % of portfolio\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@unique([userId, tokenAddress])\n  @@index([userId])\n}\n\n// Strategy performance tracking\nmodel StrategyPerformance {\n  id           String       @id @default(cuid())\n  userId       String\n  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)\n  strategyType StrategyType\n\n  periodStart DateTime\n  periodEnd   DateTime\n\n  tradesCount Int\n  winCount    Int\n  lossCount   Int\n  winRate     Float\n\n  totalPnl    String\n  totalPnlPct Float\n\n  bestTrade    String?\n  worstTrade   String?\n  avgTradeSize String?\n\n  createdAt DateTime @default(now())\n\n  @@index([userId])\n  @@index([strategyType])\n}\n\n// Token whitelist for conservative strategies\nmodel TokenWhitelist {\n  id           String    @id @default(cuid())\n  tokenAddress String    @unique\n  tokenSymbol  String\n  riskLevel    RiskLevel\n\n  minMarketCap String?\n  verified     Boolean @default(false)\n  notes        String?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nenum RiskLevel {\n  LOW\n  MEDIUM\n  HIGH\n}\n\n// Agent execution log\nmodel AgentLog {\n  id     String  @id @default(cuid())\n  userId String?\n\n  action  String // \"analyze\", \"trade\", \"rebalance\", etc.\n  details Json?\n\n  success Boolean\n  error   String?\n\n  createdAt DateTime @default(now())\n\n  @@index([userId])\n  @@index([action])\n}\n"
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"walletAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"vaultAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"xHandle\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"xUserId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"xAnalysis\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"strategyType\",\"kind\":\"enum\",\"type\":\"StrategyType\"},{\"name\":\"confidenceThreshold\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"maxTradeAmount\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"autoTrade\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"autoRebalance\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"rebalanceInterval\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"stopLossPercent\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"takeProfitPercent\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"riskProfile\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"trades\",\"kind\":\"object\",\"type\":\"Trade\",\"relationName\":\"TradeToUser\"},{\"name\":\"positions\",\"kind\":\"object\",\"type\":\"Position\",\"relationName\":\"PositionToUser\"},{\"name\":\"performance\",\"kind\":\"object\",\"type\":\"StrategyPerformance\",\"relationName\":\"StrategyPerformanceToUser\"}],\"dbName\":null},\"Trade\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"TradeToUser\"},{\"name\":\"tokenAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"tokenSymbol\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"action\",\"kind\":\"enum\",\"type\":\"TradeAction\"},{\"name\":\"amountIn\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"amountOut\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"priceAtTrade\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"confidence\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"signalSource\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"reasoning\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"txHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"status\",\"kind\":\"enum\",\"type\":\"TradeStatus\"},{\"name\":\"error\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"executedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Position\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"PositionToUser\"},{\"name\":\"tokenAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"tokenSymbol\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"balance\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"costBasis\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"entryPrice\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"currentPrice\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"currentValue\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"unrealizedPnl\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"unrealizedPnlPct\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"targetAllocation\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"StrategyPerformance\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"StrategyPerformanceToUser\"},{\"name\":\"strategyType\",\"kind\":\"enum\",\"type\":\"StrategyType\"},{\"name\":\"periodStart\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"periodEnd\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"tradesCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"winCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"lossCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"winRate\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"totalPnl\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"totalPnlPct\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"bestTrade\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"worstTrade\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"avgTradeSize\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"TokenWhitelist\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"tokenAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"tokenSymbol\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"riskLevel\",\"kind\":\"enum\",\"type\":\"RiskLevel\"},{\"name\":\"minMarketCap\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"verified\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"notes\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"AgentLog\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"action\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"details\",\"kind\":\"scalar\",\"type\":\"Json\"},{\"name\":\"success\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"error\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null}},\"enums\":{},\"types\":{}}")
defineDmmfProperty(exports.Prisma, config.runtimeDataModel)
config.compilerWasm = {
      getRuntime: async () => require('./query_compiler_fast_bg.js'),
      getQueryCompilerWasmModule: async () => {
        const { Buffer } = require('node:buffer')
        const { wasm } = require('./query_compiler_fast_bg.wasm-base64.js')
        const queryCompilerWasmFileBytes = Buffer.from(wasm, 'base64')

        return new WebAssembly.Module(queryCompilerWasmFileBytes)
      },
      importName: './query_compiler_fast_bg.js',
    }

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient
Object.assign(exports, Prisma)
